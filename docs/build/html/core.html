<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Basic Image Processing &mdash; PyFibreBundle  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Linear Interpolation" href="linear_interp.html" />
    <link rel="prev" title="PyFibreBundle" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> PyFibreBundle
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basic Image Processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#getting-started-using-oop">Getting Started using OOP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started-using-lower-level-functions">Getting Started Using Lower-Level Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="linear_interp.html">Linear Interpolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="mosaicing.html">Mosaicing</a></li>
<li class="toctree-l1"><a class="reference internal" href="super_res.html">Super Resolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Function Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyFibreBundle</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Basic Image Processing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/core.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="basic-image-processing">
<h1>Basic Image Processing<a class="headerlink" href="#basic-image-processing" title="Permalink to this headline"></a></h1>
<p>PyFibreBundle includes several functions for basic processing of bundle images, including locating, cropping and masking the bundle and removing the core pattern using spatial filtering. The easiest way to use this functionality is via the PyBundle class, but it is also possible to use the lower-level functions directly.</p>
<section id="getting-started-using-oop">
<h2>Getting Started using OOP<a class="headerlink" href="#getting-started-using-oop" title="Permalink to this headline"></a></h2>
<p>Begin by importing the libary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pybundle</span> <span class="kn">import</span> <span class="n">PyBundle</span>
</pre></div>
</div>
<p>Instantiate an object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span> <span class="o">=</span> <span class="n">PyBundle</span><span class="p">()</span>
</pre></div>
</div>
<p>To process an image <code class="docutils literal notranslate"><span class="pre">img</span></code> we then use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">procImage</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>However, this will do nothing to the raw image unless we first set some parameters. First we define what type of core-removal we would like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_core_method</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">FILTER</span><span class="p">)</span>   <span class="c1"># Choose to use a Gaussian filter</span>
<span class="n">pyb</span><span class="o">.</span><span class="n">set_filter_size</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>          <span class="c1"># Gaussian filter sigma is 2.5 pixels</span>
</pre></div>
</div>
<p>We might also want to crop the image to the bundle. This can be done automically using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_auto_loc</span><span class="p">(</span><span class="n">calibImg</span><span class="p">)</span>        <span class="c1"># Automatically locate bundle in image</span>
<span class="n">pyb</span><span class="o">.</span><span class="n">set_crop</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>                <span class="c1"># Output images will be cropped to a square around the bundle</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">calibImg</span></code> is a well-illuminated image which will allow the bundle to be located. This may be the same image as <code class="docutils literal notranslate"><span class="pre">img</span></code>.</p>
<p>Alternatively, we can specify the location of the bundle using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_bundle_loc</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">loc</span></code> is a tuple of (xCentre, yCentre, radius) for the bundle.</p>
<p>It is often useful to set all pixels outside the bundle to 0, which will be done if we set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_auto_mask</span><span class="p">(</span><span class="n">calibImg</span><span class="p">)</span>
</pre></div>
</div>
<p>The output image type can be set using, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_output_type</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>      <span class="c1"># Output images will be 8 bit</span>
</pre></div>
</div>
<p>where any numpy data type can be used. The output will simply be cast to this format without any scaling, unless we set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_auto_contrast</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>in which case the image will be first scaled to between 0 and 255 if an 8 bit output type is set, or between 0 and 65535 if a 16 bit output type is set, or between 0 and 1 if a non-integer output type is set.</p>
<p>To use triangular linear interpolation rather than Gaussian filtering, set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_core_method</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">TRILIN</span><span class="p">)</span>
</pre></div>
</div>
<p>and provide a calibration image which has all cores illuminated using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_calib_image</span><span class="p">(</span><span class="n">calibImg</span><span class="p">)</span>
</pre></div>
</div>
<p>The output image size is set by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_grid_size</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span>
</pre></div>
</div>
<p>It is usually preferable to provide a normalisation image with uniform illumination to minimise grainyness to due variations between cores, this can usually be the same image as used for calibration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">set_normalise_image</span><span class="p">(</span><span class="n">calibImage</span><span class="p">)</span>
</pre></div>
</div>
<p>(Note UK spelling of normalise). Calibration then needs to be called one-time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pyb</span><span class="o">.</span><span class="n">calibrate</span><span class="p">()</span>
</pre></div>
</div>
<p>(If not called explicitly it will be called the first time you attempt to reconstruct an image). We are then ready to reconstruct:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">procImg</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="linear_interp.html"><span class="doc">Linear Interpolation</span></a>  page for more details.</p>
</section>
<section id="getting-started-using-lower-level-functions">
<h2>Getting Started Using Lower-Level Functions<a class="headerlink" href="#getting-started-using-lower-level-functions" title="Permalink to this headline"></a></h2>
<p>The lower-level functions can be called directly if greater control is needed.</p>
<p>Begin by importing the library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pybundle</span>
</pre></div>
</div>
<p>To locate the bundle in an image, we use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">loc</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">find_bundle</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>This works best for background or structureless images acquired through a bundle. The function returns <code class="docutils literal notranslate"><span class="pre">loc</span></code> which is a tuple of the bundles (x centre, y centre, radius).</p>
<p>If we would like to mask out pixels outside of the image, we can use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">maskedImg</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">auto_mask</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, we can generate a mask using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mask</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">get_mask</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
</pre></div>
</div>
<p>and apply this mask to any future image using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">maskedImg</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">apply_mask</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p>This is more useful in general, since the location of the bundle is best determined using a calibration image, and the same mask can then be used for all subsequent images.</p>
<p>We can also crop the image to a square around the bundle using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">croppedImg</span><span class="p">,</span> <span class="n">newloc</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">crop_rect</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have specified the bundle location <code class="docutils literal notranslate"><span class="pre">loc</span></code>, a tuple of (x centre, y centre, radius) as output by <code class="docutils literal notranslate"><span class="pre">find_bundle</span></code>. Note that the output of is a tuple of <code class="docutils literal notranslate"><span class="pre">(image,</span> <span class="pre">newloc)</span></code> where <code class="docutils literal notranslate"><span class="pre">newloc</span></code> is the new location of the bundle in the cropped image.</p>
<p>To crop and mask an image in a single step use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">croppedImg</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">auto_mask_crop</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Spatial filtering can be used to remove the core pattern (alternatively, linear interpolation is also available). To apply a Gaussian smoothing filter, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">smoothedImg</span> <span class="o">=</span> <span class="n">pubundle</span><span class="o">.</span><span class="n">g_filter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">filterSize</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">filterSize</span></code> is the sigma of the 2D Gaussian smoothing kernel. A convenient function to filter, mask and crop an image is given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">smoothedImg</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">crop_filter_mask</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">loc</span></code> is the location of the bundle, determined using <code class="docutils literal notranslate"><span class="pre">find_bundle</span></code> on a calibraton image, and <code class="docutils literal notranslate"><span class="pre">mask</span></code> is a mask created by <code class="docutils literal notranslate"><span class="pre">get_mask</span></code>.</p>
<p>The core spacing of the bundle can be found using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coreSpacing</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">get_core_spacing</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>This can then be used to define a custom edge filter using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">filter</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">edge_filter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span>  <span class="n">edgeLocation</span><span class="p">,</span> <span class="n">edgeSlope</span><span class="p">)</span>
</pre></div>
</div>
<p>This defines a Fourier domain filter with a cosine smoothed cut-off at the spatial frequency corresponding to the spatial distance <code class="docutils literal notranslate"><span class="pre">edgeLocation</span></code>. <code class="docutils literal notranslate"><span class="pre">edgeSlope</span></code> defines the smoothness of the cut-off; a value of 0 gives a rectangular function. <code class="docutils literal notranslate"><span class="pre">img</span></code> merely needs to be a numpy array the same size as the image(s) to be filtered. <code class="docutils literal notranslate"><span class="pre">edgeLocation</span></code> should typically be <code class="docutils literal notranslate"><span class="pre">1.6</span> <span class="pre">*</span> <span class="pre">coreSpacing</span></code>, and edgeSlope is not critical, but a value of <code class="docutils literal notranslate"><span class="pre">0.1</span> <span class="pre">*</span> <span class="pre">coreSpacing</span></code> generally works well. To apply the filter use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">smoothedImg</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">filter_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="nb">filter</span><span class="p">)</span>
</pre></div>
</div>
<p>To perform linear interpolation using static methods, first perform a calibration using the calibration image <code class="docutils literal notranslate"><span class="pre">calibImg</span></code>, a 2D numpy array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coreSize</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">gridSize</span> <span class="o">=</span> <span class="mi">512</span>
<span class="n">calib</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">calib_tri_interp</span><span class="p">(</span><span class="n">calibImg</span><span class="p">,</span> <span class="n">coreSize</span><span class="p">,</span> <span class="n">gridSize</span><span class="p">,</span> <span class="n">normalise</span> <span class="o">=</span> <span class="n">calibImg</span><span class="p">,</span> <span class="n">automask</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we have specified <code class="docutils literal notranslate"><span class="pre">coreSize</span> <span class="pre">=</span> <span class="pre">3</span></code> which is the approximate core spacing in the image. This assists the calibration routine in finding all cores. If unknown it can be estimate using <code class="docutils literal notranslate"><span class="pre">find_core_spacing</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gridSize</span></code> is the number of pixels in each dimensions of the reconstructed image, which is square.</p>
<p>Finally, we have specified to use the <code class="docutils literal notranslate"><span class="pre">calibImg</span></code> for normalisation. This means that the intensity extracted from each core during imaging will be normalised with respect to the intensity from the calibration image, removing effects due to non-uniform cores. If this is not done (i.e. normalise is left as the default <code class="docutils literal notranslate"><span class="pre">None</span></code>) then images may appear grainy.</p>
<p>To reconstruct an image <code class="docutils literal notranslate"><span class="pre">img</span></code>, a 2D numpy array, we then call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">imgRecon</span> <span class="o">=</span> <span class="n">pybundle</span><span class="o">.</span><span class="n">recon_tri_interp</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">calib</span><span class="p">)</span>
</pre></div>
</div>
<p>This returns a 2D numpy array of size <code class="docutils literal notranslate"><span class="pre">(gridSize,</span> <span class="pre">gridSize)</span></code> containing the image with the core pattern removed.</p>
<p>For all optional parameters refer to the <a class="reference internal" href="functions.html"><span class="doc">function reference</span></a> for <code class="docutils literal notranslate"><span class="pre">calib_tri_interp</span></code> and <code class="docutils literal notranslate"><span class="pre">recon_tri_interp</span></code>.</p>
</section>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline"></a></h2>
<p>An example is provided in “examples\mosaicing_example.py”</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="PyFibreBundle" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="linear_interp.html" class="btn btn-neutral float-right" title="Linear Interpolation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Mike Hughes.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>